[{"title":"nodejs定时调用阿里云天气api","date":"2017-03-22T11:31:09.000Z","path":"2017/03/22/weatherapi/","text":"获取天气nodejs接口在实际开发中需要定时调用,在此处需要安装node-schedule定时模块1sudo npm install node-schedule 123456var url = 'http://saweather.market.alicloudapi.com/gps-to-weather';var params = &#123; //还有一些可选参数,参照api from: 5, needAlarm: 1, needIndex: 1&#125; 阿里云天气预报api: click注册登录购买免费版,会提供给你一个AppKey, AppSecret和AppCode,用于请求验证,注意是放在头部headers内的 12345var headers = &#123; 'User-Agent': 'Super Agent/0.0.1', 'Content-Type': 'application/x-www-form-urlencoded', 'Authorization': 'APPCODE ' + 'your appcode' //填写你自己的appcode&#125; ok! 参数请求参数都有了, 现在就只要给请求设置一个定时任务了, 我在这里使用了node-schedule这个模块, 当然你也可以自己写定时器, 功能还是都能实现的.在实际开发中, 遇到需要定时任务的工作还是蛮多的, 比如: 定时发送消息, 导出or清除数据, 定时请求api等等. 12345678910111213141516171819var schedule = require('node-schedule');var request = require('request');schedule.scheduleJob('30 30 * * * *', function()&#123; var options = &#123; url: url, method: 'GET', headers: headers, //请求头 qs: params //请求参数 &#125; //Start the request request(options, function(error, response, body) &#123; if(error)&#123; &#125;else&#123; //api调用成功后的操作 &#125; &#125;)&#125;); 以上的6个占位符从左到右分别代表：秒、分、时、日、月、周几, 上述例子中就是每个小时的30分30秒回执行一次.1234//范围触发schedule.scheduleJob('1-30 * * * * *', function()&#123; //表示每分钟的1~30秒都会执行 &#125;) 12345678910111213/*secondminutehourdatemonthyeardayOfWeek*///对象文本定义触发条件schedule.scheduleJob(&#123;hour: 14, minute: 30, dayOfWeek: 1&#125;, function()&#123; // 每周一下午14时30分执行 &#125;) 还有好几种设置的方式,自己摸索吧. node-schedule: github","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"node-schedule","slug":"node-schedule","permalink":"http://yoursite.com/tags/node-schedule/"},{"name":"天气","slug":"天气","permalink":"http://yoursite.com/tags/天气/"}]},{"title":"数组中元素前后(上下)移动函数","date":"2017-03-21T08:57:54.000Z","path":"2017/03/21/swapItems/","text":"数组内元素交换在使用angular或vue时, ng-repeat和v-for都能很方便得到遍历的数组中的某个元素的$index, 本文以在angular下为例: 1234var swapItems = function(arr, index1, index2) &#123; arr[index1] = arr.splice(index2, 1, arr[index1])[0]; return arr;&#125;; 该函数使得index1,index2两位置的元素交换 元素上移或下移上移即将 选中元素与上一个元素交换位置,注意边界123456$scope.upMove = function(arr, $index) &#123; if($index == 0) &#123; return; &#125; swapItems(arr, $index, $index - 1);&#125;; 同理 下移即将 选中元素与下一个元素交换位置123456$scope.downMove = function(arr, $index) &#123; if($index == arr.length -1) &#123; return; &#125; swapItems(arr, $index, $index + 1);&#125;;","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"前端面试题(持续更新)","date":"2017-03-18T02:41:39.000Z","path":"2017/03/18/interviewques/","text":"孔夫子曰: 学而时习之,不亦乐乎. HTML+CSS篇 1. 行内元素,块级元素有哪些?以及CSS的盒子模型又是什么? 行内元素: div p h1-h4 ul 块级元素: a b br i span input select CSS盒子模型: border margin外边距 padding内边距 2. 清除浮动的几种方式&nbsp;①. clear: both&nbsp;②. overflow: auto&nbsp;③. 使用after伪元素清除浮动 3. CSS选择器有哪些?有类别选择器, 标签选择器, id选择器, 后代选择器(空格), 子选择器(&gt;指得是直接后代), 伪类选择器(:hover :focus等等), 通用选择器(可以跟后代选择器搭配使用,如.father *{father元素后代所有元素都是用这个样式}), 群组选择器(元素之间用逗号分隔), 相邻同胞选择器, 属性选择器(如input[type=”text”]) Tip: Practice is the sole of criterion of truth. 实践是检验真理的唯一标准. JavaScript篇1.寻找字符串中出现次数最少的、并且首次出现位置最前的字符.这里我的思路是先统计字符出现的次数,整理成对象,如a出现1次b出现2次{a: 1, b: 2},再for循环对象,找出出现次数最少并且为之最前的字符.不同的解决方法: 戳 2.","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"input的placeholder打字效果的实现","date":"2017-03-17T07:35:20.000Z","path":"2017/03/17/placeholder/","text":"看到一个轻量级js插件,蛮有意思的.(主要是上次出去面试有点受刺激,第四轮架构师大神,问的问题其实很基本,但是自己就是没答上来,真的挺可惜,不过面试题目还像也可以写一篇分享一下==…建议多去看看github上的各位大牛的代码,学习吧骚年) 源码地址superplaceholder.js: github 1. 打字效果实现原理模拟打字效果的实现,其实就是主要是定时器的工作了,只要根据提供的texts(placeholder值的数组),textDelay(切换句子时的时间间隔),letterDelay(每打一个字的时间间隔),定时给input元素setAttribute placeholder属性. 还要考虑到是否聚焦startOnFocus的时候开始执行该打字效果,是否循环loop,以及打字光标cursor. 2. Start检查input是否支持placeholder属性123//创建一个input元素,判断是否支持placeholder属性var test = document.createElement('input');var isPlaceHolderSupported = ('placeholder' in test); 构造方法定义默认参数123456789//默认参数optionsvar defaults = &#123; letterDelay: 100, //每个字显示的时间间隔 textDelay: 1000, //句子切换时间间隔 loop: false, //是否循环显示 startOnFocus: true, //获取焦点,显示打字效果 showCursor: true, //显示打字效果光标 cursor: '|' //光标&#125; 构造PlaceHolder方法123456789//构造一个PlaceHolder方法 options里没有设置的属性就使用默认的function PlaceHolder(el, texts, options)&#123; this.el = el; this.texts = texts; options = options || &#123;&#125;; this.options = extend(defaults, options); this.timeouts = []; this.begin();&#125; 关于这里的extend函数,主要是将自定义参数值与默认参数值整合,返回的一个参数对象1234567function extend(obj1, obj2)&#123; var obj = &#123;&#125;; for(key in obj1)&#123; obj[key] = obj2[key]===undefined ? obj1[key] : obj2[key]; &#125; return obj;&#125; 构造函数的原型及方法这里先说明一下,需要的方法有:begin()初始化,设置打印texts的定时器和打印text里的每个字符的定时器,以及失去焦点时清除所有定时器cleanUp()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//初始化开始PlaceHolder.prototype.begin = function()&#123; var self = this, temp; //初始时placeholder的值 self.originalPlaceholder = self.el.getAttribute('placeholder'); //初始化后直接开始打字效果显示placeholder or 需要手动聚焦开始或者停止 if(self.options.startOnFocus)&#123; self.el.addEventListener('focus', function()&#123; self.processText(0); &#125;); self.el.addEventListener('blur', function()&#123; self.cleanUp(); &#125;) &#125;else&#123; self.processText(0); &#125;&#125;//textsPlaceHolder.prototype.processText = function(index)&#123; var self = this, timeout; self.typeString(self.texts[index], function()&#123; //typeString显示完一个短句,再回调,设置下一个短句的定时显示 timeout = setTimeout(function()&#123; self.processText(self.options.loop ? ((index + 1) % self.texts.length) : (index + 1)); &#125;, self.options.textDelay); self.timeouts.push(timeout); &#125;);&#125;//textPlaceHolder.prototype.typeString = function(str, callback)&#123; var self = this, timeout; if(!str)&#123; return false; &#125; //给每增加一个字符显示设置定时,即每增加一个letterDelay, 调用函数给input的placeholder设置对应的str for(let i = 0; i &lt; str.length; i++)&#123; timeout = setTimeout(setTimeoutCallback, i * self.options.letterDelay, i); self.timeouts.push(timeout); &#125; // function setTimeoutCallback(index)&#123; //index == str.length - 1 便是显示到了一个text的最后的一个字符 self.el.setAttribute('placeholder', str.substring(0, index + 1) + (index === str.length - 1 || !self.options.showCursor ? '' : self.options.cursor)); if(index == str.length - 1)&#123; callback(); //一个text显示完整后,回调,设置下一个text的 &#125; &#125;&#125;//失去焦点之后触发,设置为原来的默认值, 并且清空定时器PlaceHolder.prototype.cleanUp = function()&#123; // Stop timeouts for (var i = this.timeouts.length; i--;) &#123; clearTimeout(this.timeouts[i]); &#125; this.el.setAttribute('placeholder', this.originalPlaceholder); this.timeouts.length = 0;&#125; 声明PlaceHolder对象函数,判断是否支持placeholder属性,并new之前的构造函数, 并抛出该函数对象1234567891011121314151617181920var splaceholder = function(params)&#123; if(!isPlaceHolderSupported)&#123; return; &#125; new PlaceHolder(params.el, params.texts, params.options);&#125;if( typeof exports === 'object' ) &#123; module.exports = splaceholder;&#125;// AMD moduleelse if( typeof define === 'function' &amp;&amp; define.amd ) &#123; define(function () &#123; return splaceholder; &#125;);&#125;// 浏览器window对象else &#123; window.splaceholder = splaceholder;&#125; 好的,接下来我们只要在页面调用就好了1234567891011&lt;input type=\"text\" name=\"\" placeholder=\"colleague\" id=\"colleague\"&gt;splaceholder(&#123; el: colleague, texts: [\"caishuanglin\", \"linxianshen\", \"xinmencai\"], options: &#123; loop: true, letterDelay: 100, startOnFocus: false &#125;&#125;) 嗯,自己动手试试吧.(ง •̀_•́)ง","tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"},{"name":"placeholder","slug":"placeholder","permalink":"http://yoursite.com/tags/placeholder/"}]},{"title":"Hello World","date":"2017-03-16T09:04:57.000Z","path":"2017/03/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]