[{"title":"vue下跨域设置","date":"2017-07-24T02:23:27.000Z","path":"2017/07/24/webpackproxy/","text":"在用vue做简易播放器的时候, 调用网易云音乐api出现了跨域问题. 文档地址: https://vuejs-templates.github.io/webpack/proxy.html 在用vue-cli生成的项目下, 有个/config/index.js文件, 其中有项dev.proxyTable的参数配置,这个参数主要是一个地址映射表，你可以通过设置将复杂的url简化, 你可以参照如下例子: 12345678910proxyTable: &#123; // proxy all requests starting with /api to jsonplaceholder '/api': &#123; target: 'http://163.opdays.com', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125;&#125; 做了以上配置后, 当我们在请求中的参数写成”/api/playlist?id=317921676”,即访问的是”http://163.opdays.com/playlist?id=317921676“ 这里changeOrigin的值为true的时候, 那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。 vue-cli的这个设置其实是依赖于其使用的http-proxy-middleware插件, 仔细看vue的目录结构, 你会发现build下的dev-server.js下有写一些关于proxyTable的使用.详细的配置说明请参照github: https://github.com/chimurai/http-proxy-middleware","tags":[{"name":"webpack","slug":"webpack","permalink":"https://linxianshen.github.io/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://linxianshen.github.io/tags/vue/"},{"name":"跨域","slug":"跨域","permalink":"https://linxianshen.github.io/tags/跨域/"}]},{"title":"CSS Secrets(CSS揭秘) 读书笔记","date":"2017-07-03T08:03:06.000Z","path":"2017/07/03/csssecrets/","text":"","tags":[]},{"title":"note0508(五月)","date":"2017-05-08T03:59:09.000Z","path":"2017/05/08/worknote0508/","text":"1.在angular中监听路由变化的事件(离开本页面前, 做某些需要的事).比如,离开时清除定时器等等123$scope.$on(\"$stateChangeStart\", function(event, toState, toParams, fromState, fromParams)&#123; //do something&#125;) 2.css中的背景图定位扩展background-position: 20px 20px; 是根据元素左上角开始定位的.那么如何将背景图相对元素右上角定位, 并且能准确的给予距离右边多少px这里有个小tip:可以跟border结合使用, border-right: 20px solid transparent; background-position: 100% 20px;这样得到的效果就是背景图定位在距离元素右侧20px的位置; 3.微信开发中, 设置标题1234567891011// 修改微信 titlefunction setWechatTitle(title) &#123; var $body = $('body') document.title = title; // hack在微信等webview中无法修改document.title的情况 var $iframe = $('&lt;iframe src=\"/favicon.ico\"&gt;&lt;/iframe&gt;').on('load', function() &#123; setTimeout(function() &#123; $iframe.off('load').remove() &#125;, 0) &#125;).appendTo($body)&#125; 调用setWechatTitle()就ok了. 4.js中的变量提升123456var name = 'csl';(function()&#123; alert(name); //undefined var name = 'pickup'; alert(name); //pickup&#125;)(); 在自执行函数中,第一个name是因为函数中的变量提升了,如下1234567var name = 'csl';(function()&#123; var name; alert(name); //undefined name = 'pickup'; alert(name); //pickup&#125;)(); 5.避免连续点击按钮.重复请求123456789101112131415161718192021222324app.config(['$provide', function ($provide) &#123; $provide.decorator('ngClickDirective',['$delegate','$timeout', function ($delegate,$timeout) &#123; var original = $delegate[0].compile; var delay = 1000; $delegate[0].compile = function (element, attrs, transclude) &#123; var disabled = false; function onClick(evt) &#123; if (disabled) &#123; evt.preventDefault(); evt.stopImmediatePropagation(); &#125; else &#123; disabled = true; $timeout(function () &#123; disabled = false; &#125;, delay, false); &#125; &#125; // scope.$on('$destroy', function () &#123; iElement.off('click', onClick); &#125;); element.on('click', onClick); return original(element, attrs, transclude); &#125;; return $delegate; &#125;]); &#125;]) 6.sql语句,查询出来的字段拼接CONCAT()函数①.CONCAT(str1, str2, …) 返回为连接参数产生的字符串.但是只要有一个参数为null, 最后拼接返回的结果也为null ②.CONCAT_WS(separator, str1, str2, …) 函数的字面意思就是concat width separator, 按分隔符来拼接字符串. 该函数不会忽律任何空字符串. example: CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) —&gt; First name,Last Name ③.GROUP_CONCAT() 分组查询出来的结果拼接而成 example: GROUP_CONCAT(id separator ‘,’) —&gt; 分组查询出来的所有id拼接 GROUP_CONCAT(CONCAT_WS(‘,’,id,name) separator ‘.’) —&gt; 先拼接对应的id和name , 再拼接分组ps: GROUP_CONCAT()函数中也可以使用distinct, order by, desc等等条件 7.关于setTimeout的参数问题和es6的promise在看es6文档的promise时, 突然看到setTimeout出现了三个参数, 一下没反应过来. 后来又查了一下, 发现setTimeout前两个参数肯定是一个function和delay, 至于第三个以及后面的参数都是可以作为setTimeout中的function函数的参数.首先来看一下, es6文档中的代码, 一个简单的promise对象的例子123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 可见, timeout方法返回一个Promise实例, 表示一段时间后发生, 实例状态变化为resolved, 就会触发then方法, 此处’done’就是作为参数进入到resolve方法中的.then完整是这样的12345Promise.resolve('Success').then(function(value)&#123; console.log(value); //Success&#125;, function()&#123; //不会被调用&#125;) Promise.resolve返回一个promise对象，这个promise对象是被解析后（resolved）的. Promise.resolve传的参数可以是value, promise对象, 还可以是thenable(带有then的方法).ps:可玩性很高 参见MDN Promise和es6 阮一峰 8.","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"},{"name":"angular","slug":"angular","permalink":"https://linxianshen.github.io/tags/angular/"},{"name":"工作笔记","slug":"工作笔记","permalink":"https://linxianshen.github.io/tags/工作笔记/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://linxianshen.github.io/tags/学习笔记/"}]},{"title":"input输入框校对气泡插件的实现","date":"2017-04-13T04:00:41.000Z","path":"2017/04/13/inputtip/","text":"前提啊…这是上次清明回家上网买车票是看到的一个input显示插件,感觉比较常用的.实现起来也不难, 就想着抽空也来写一个类似的气泡弹框插件. 清明到现在也鸽了这么久了, 找了个时间现在来分享一下实现的步骤… 代码在这:github 实现过程思路类似. 参考之前的placeholder属性打字效果superplaceholder: 传送门 整体的思路也就是前端调用tipInput()方法去生成一个气泡Div, 并且要相对需要此功能的input的种种属性. 因此在这里就直接将input的id作为参数, 调用气泡生成的方法1tipInput(&#123;el: tip&#125;) //tip为input的id 校验传的参数是否input元素并且是text属性的输入框123456var tipInput = function(params) &#123; if (params.el.tagName == 'INPUT' &amp;&amp; params.el.type == 'text') &#123; //判断元素是否为input text的 new InputTip(params.el); &#125; return;&#125; 接下来的操作基本都是对获取到的input#tip元素的属性的应用 在createTipDiv方法中,主要的操作就是, 动态生成tipwrap内容节点, 并赋予宽高, 定位等属性.在创建成功之后,为input添加focus, blur以及keyup键盘事件, 来控制tipwrap的显示与否. 12345678910111213141516171819202122232425262728293031function InputTip(el) &#123; this.el = el; this.createTipDiv(); //create the tip based on input elem &#125;//create tipwrap divInputTip.prototype.createTipDiv = function() &#123; let self = this; let elem = document.createElement(\"div\"); elem.id = 'tipwrap'; //safari不支持这个写法的 // elem.style = 'position: absolute;color: black;top:' + (self.el.offsetTop - self.el.clientHeight - 14) + 'px;left:' + self.el.offsetLeft + 'px;'; elem.style.position = 'absolute'; elem.style.color = \"black\"; elem.style.top = self.el.offsetTop - self.el.clientHeight - 14 + 'px'; elem.style.left = self.el.offsetLeft + 'px'; elem.hidden = true; //begin hidden elem.innerHTML = \"&lt;div id='rect' style='background: #eee;border-radius: 4px;padding: 4px;font-size:\" + (self.el.offsetHeight - 6) + \"px;height:\" + self.el.clientHeight + \"px;min-width:\" + self.el.clientWidth + \"px;'&gt;&lt;/div&gt;&lt;span id='triangle' style='display: block;margin-left:\" + (self.el.clientWidth / 10) + \"px;width: 0;height: 0;border-left: 5px solid transparent;border-right: 5px solid transparent;border-top: 5px solid #eee;'&gt;&lt;/span&gt;\"; self.el.parentElement.appendChild(elem); self.el.addEventListener('focus', function() &#123; if (self.el.value) &#123; elem.hidden = false; //show tipwrap &#125; &#125;); self.el.addEventListener('blur', function() &#123; elem.hidden = true; // hide tipwrap &#125;); self.el.addEventListener('keyup', function() &#123; self.textShowRealTime(elem); //show in time &#125;);&#125; input的keyup事件, 就是每次按下都去重新给气泡上的内容赋值 1234567891011//show in time when keyup eventInputTip.prototype.textShowRealTime = function(elem) &#123; let self = this; let tipNode = document.getElementById(\"triangle\"); if (self.el.value) &#123; elem.hidden = false; &#125; else &#123; elem.hidden = true; &#125; elem.children[0].innerHTML = self.el.value;&#125; 跟头像一样丑是丑了点, 客官将就看看吧… 哦, 还有, 剧透一下人民的名义, o(*≧▽≦)ツ┏━┓铁胆神侯朱无视才是最大boss.","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"},{"name":"input","slug":"input","permalink":"https://linxianshen.github.io/tags/input/"},{"name":"气泡","slug":"气泡","permalink":"https://linxianshen.github.io/tags/气泡/"},{"name":"plugin","slug":"plugin","permalink":"https://linxianshen.github.io/tags/plugin/"}]},{"title":".gitignore配置","date":"2017-04-08T09:08:06.000Z","path":"2017/04/08/gitignore/","text":"有些时候你必须把某些文件放到Git工作目录当中, 但是又不能提交他们. 当然Git也为了我们提供了解决方法, 我们可以在git工作区的根目录下,创建一个特殊的.gitignore文件, 然后讲我们要忽略的文件名填进去, Git就会自动忽略这些文件 忽略文件的原则: 1: 忽略操作系统自动生成的文件，比如缩略图等; 2: 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 3: 忽略某些通过某些文件自动生成的, 那么自动生成的文件就没必要放进版本库 比如一些在工作目录中的安装的依赖模块, 是根据package.json来生成的, 就没必要放入版本库 进入项目文件, touch .gitignore创建文件 并进行配置12345678node-modules/*.py //表示忽略所有py文件, *通配多个字符fold/ //表示 fold文件夹下的所有文件都忽略, 这个fold文件夹不管是在根目录下,还是某个文件夹的子目录下,都会被忽略/fold/ //表示根目录下的fold目录的全部内容/*!/fold //表示忽略全部内容, 不忽略根目录下的fold文件夹","tags":[{"name":"git","slug":"git","permalink":"https://linxianshen.github.io/tags/git/"},{"name":".gitignore","slug":"gitignore","permalink":"https://linxianshen.github.io/tags/gitignore/"}]},{"title":"Git命令操作-上传文件到github仓库","date":"2017-04-07T06:17:41.000Z","path":"2017/04/07/gitcommand/","text":"作为一个coder, 熟练使用git命令是必须的, 你既可以在github上寻找对你有帮助的开源项目, 也可以将自己的代码共享开源出去.那么如何将本地的项目文件上传至github上呢. 如果是首次上传项目文件则:先进入文件夹, 通过git init把这个目录变成git可以管理的仓库1git init 把文件添加到版本库中, 使用git add .命令, 不要忘了’.’, 意思是添加文件夹下的所有文件到暂存区里1git add . 用命令git commit告诉Git把文件提交到仓库, 引号里面的是提交说明1git commit -m '提交上传备注说明' 关联到远程库1git remote add origin 远程库地址 获取远程库与本地同步合并(如果远程库不为空, 则必须做这一步, 否则后面会提交失败)1git pull --rebase origin master 本地库内容推送到远程, 使用git push命令,实际上是把当前分支master推送到远程。执行此命令后会要求输入用户名、密码，验证通过后即开始上传1git push -u origin master 在上传完项目,之后又修改了,并且再上传需要的git命令 查看项目文件状态,提示了本地修改了哪些文件1git status 把新增修改的文件到暂存区1git add -A 添加备注git commit -m “备注说明”更新git pull –rebase origin master上传git push -u origin master","tags":[{"name":"git命令","slug":"git命令","permalink":"https://linxianshen.github.io/tags/git命令/"}]},{"title":"js生成网页pdf或打印的方法","date":"2017-03-27T08:59:41.000Z","path":"2017/03/27/printpdf/","text":"浏览器网页中点击鼠标右键, 有打印操作, 但是这样会把整个网页的内容都包含到pdf里面.现在有个需求, 就是要将网页中的某一块div里面的内容生成pdf, 另存为或者打印. 好.直接上代码吧.主要就是js的document对象的使用 12345678var createPdf = () =&gt; &#123; let newWindow = window.open(\"_blank\"); //打开新窗口 let codestr = document.getElementById(\"pdf-wrap\").innerHTML; //获取需要生成pdf页面的div代码 newWindow.document.write(codestr); //向文档写入HTML表达式或者JavaScript代码 newWindow.document.close(); //关闭document的输出流, 显示选定的数据 newWindow.print(); //打印当前窗口 return true;&#125; 调用成功会弹出打印或保存pdf的窗口 打印的文档可以自由拼接…自己去网页上瞎jb存pdf吧.","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"}]},{"title":"nodejs定时调用阿里云天气api","date":"2017-03-22T11:31:09.000Z","path":"2017/03/22/weatherapi/","text":"获取天气nodejs接口在实际开发中需要定时调用,在此处需要安装node-schedule定时模块1sudo npm install node-schedule 123456var url = 'http://saweather.market.alicloudapi.com/gps-to-weather';var params = &#123; //还有一些可选参数,参照api from: 5, needAlarm: 1, needIndex: 1&#125; 阿里云天气预报api: click注册登录购买免费版,会提供给你一个AppKey, AppSecret和AppCode,用于请求验证,注意是放在头部headers内的(别拼接到了url里==) 12345var headers = &#123; 'User-Agent': 'Super Agent/0.0.1', 'Content-Type': 'application/x-www-form-urlencoded', 'Authorization': 'APPCODE ' + 'your appcode' //填写你自己的appcode&#125; ok! 参数请求参数都有了, 现在就只要给请求设置一个定时任务了, 我在这里使用了node-schedule这个模块, 当然你也可以自己写定时器, 功能还是都能实现的.在实际开发中, 遇到需要定时任务的工作还是蛮多的, 比如: 定时发送消息, 导出or清除数据, 定时请求api等等. 12345678910111213141516171819var schedule = require('node-schedule');var request = require('request');schedule.scheduleJob('30 30 * * * *', function()&#123; var options = &#123; url: url, method: 'GET', headers: headers, //请求头 qs: params //请求参数 &#125; //Start the request request(options, function(error, response, body) &#123; if(error)&#123; &#125;else&#123; //api调用成功后的操作 &#125; &#125;)&#125;); 以上的6个占位符从左到右分别代表：秒、分、时、日、月、周几, 上述例子中就是每个小时的30分30秒回执行一次.1234//范围触发schedule.scheduleJob('1-30 * * * * *', function()&#123; //表示每分钟的1~30秒都会执行 &#125;) 12345678910111213/*secondminutehourdatemonthyeardayOfWeek*///对象文本定义触发条件schedule.scheduleJob(&#123;hour: 14, minute: 30, dayOfWeek: 1&#125;, function()&#123; // 每周一下午14时30分执行 &#125;) 还有好几种设置的方式,自己摸索吧. node-schedule: github","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://linxianshen.github.io/tags/nodejs/"},{"name":"node-schedule","slug":"node-schedule","permalink":"https://linxianshen.github.io/tags/node-schedule/"},{"name":"天气","slug":"天气","permalink":"https://linxianshen.github.io/tags/天气/"}]},{"title":"数组中元素前后(上下)移动函数","date":"2017-03-21T08:57:54.000Z","path":"2017/03/21/swapItems/","text":"数组内元素交换在使用angular或vue时, ng-repeat和v-for都能很方便得到遍历的数组中的某个元素的$index, 本文以在angular下为例: 1234var swapItems = function(arr, index1, index2) &#123; arr[index1] = arr.splice(index2, 1, arr[index1])[0]; return arr;&#125;; 该函数使得index1,index2两位置的元素交换 元素上移或下移上移即将 选中元素与上一个元素交换位置,注意边界123456$scope.upMove = function(arr, $index) &#123; if($index == 0) &#123; return; &#125; swapItems(arr, $index, $index - 1);&#125;; 同理 下移即将 选中元素与下一个元素交换位置123456$scope.downMove = function(arr, $index) &#123; if($index == arr.length -1) &#123; return; &#125; swapItems(arr, $index, $index + 1);&#125;;","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"},{"name":"angular","slug":"angular","permalink":"https://linxianshen.github.io/tags/angular/"}]},{"title":"杂记(持续更新)","date":"2017-03-18T02:41:39.000Z","path":"2017/03/18/interviewques/","text":"孔夫子曰: 学而时习之,不亦乐乎. HTML+CSS篇 1. 行内元素,块级元素有哪些?以及CSS的盒子模型又是什么? 行内元素: div p h1-h4 ul 块级元素: a b br i span input select CSS盒子模型: border margin外边距 padding内边距 2. 清除浮动的几种方式&nbsp;①. clear: both&nbsp;②. overflow: auto&nbsp;③. 使用after伪元素清除浮动 3. CSS选择器有哪些?有类别选择器, 标签选择器, id选择器, 后代选择器(空格), 子选择器(&gt;指得是直接后代), 伪类选择器(:hover :focus等等), 通用选择器(可以跟后代选择器搭配使用,如.father *{father元素后代所有元素都是用这个样式}), 群组选择器(元素之间用逗号分隔), 相邻同胞选择器, 属性选择器(如input[type=”text”]) Tip: Practice is the sole of criterion of truth. 实践是检验真理的唯一标准. JavaScript篇1.寻找字符串中出现次数最少的、并且首次出现位置最前的字符.这里我的思路是先统计字符出现的次数,整理成对象,如a出现1次b出现2次{a: 1, b: 2},再for循环对象,找出出现次数最少并且为之最前的字符.不同的解决方法: 戳 2.","tags":[{"name":"前端","slug":"前端","permalink":"https://linxianshen.github.io/tags/前端/"},{"name":"杂记","slug":"杂记","permalink":"https://linxianshen.github.io/tags/杂记/"}]},{"title":"input的placeholder打字效果的实现","date":"2017-03-17T07:35:20.000Z","path":"2017/03/17/placeholder/","text":"看到一个轻量级js插件,蛮有意思的.(主要是上次出去面试有点受刺激,第四轮架构师大神,问的问题其实很基本,但是自己就是没答上来,真的挺可惜,不过面试题目还像也可以写一篇分享一下==…建议多去看看github上的各位大牛的代码,学习吧骚年) 源码地址superplaceholder.js: github 1. 打字效果实现原理模拟打字效果的实现,其实就是主要是定时器的工作了,只要根据提供的texts(placeholder值的数组),textDelay(切换句子时的时间间隔),letterDelay(每打一个字的时间间隔),定时给input元素setAttribute placeholder属性. 还要考虑到是否聚焦startOnFocus的时候开始执行该打字效果,是否循环loop,以及打字光标cursor. 2. Start检查input是否支持placeholder属性123//创建一个input元素,判断是否支持placeholder属性var test = document.createElement('input');var isPlaceHolderSupported = ('placeholder' in test); 构造方法定义默认参数123456789//默认参数optionsvar defaults = &#123; letterDelay: 100, //每个字显示的时间间隔 textDelay: 1000, //句子切换时间间隔 loop: false, //是否循环显示 startOnFocus: true, //获取焦点,显示打字效果 showCursor: true, //显示打字效果光标 cursor: '|' //光标&#125; 构造PlaceHolder方法123456789//构造一个PlaceHolder方法 options里没有设置的属性就使用默认的function PlaceHolder(el, texts, options)&#123; this.el = el; this.texts = texts; options = options || &#123;&#125;; this.options = extend(defaults, options); this.timeouts = []; this.begin();&#125; 关于这里的extend函数,主要是将自定义参数值与默认参数值整合,返回的一个参数对象1234567function extend(obj1, obj2)&#123; var obj = &#123;&#125;; for(key in obj1)&#123; obj[key] = obj2[key]===undefined ? obj1[key] : obj2[key]; &#125; return obj;&#125; 构造函数的原型及方法这里先说明一下,需要的方法有:begin()初始化,设置打印texts的定时器和打印text里的每个字符的定时器,以及失去焦点时清除所有定时器cleanUp()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//初始化开始PlaceHolder.prototype.begin = function()&#123; var self = this, temp; //初始时placeholder的值 self.originalPlaceholder = self.el.getAttribute('placeholder'); //初始化后直接开始打字效果显示placeholder or 需要手动聚焦开始或者停止 if(self.options.startOnFocus)&#123; self.el.addEventListener('focus', function()&#123; self.processText(0); &#125;); self.el.addEventListener('blur', function()&#123; self.cleanUp(); &#125;) &#125;else&#123; self.processText(0); &#125;&#125;//textsPlaceHolder.prototype.processText = function(index)&#123; var self = this, timeout; self.typeString(self.texts[index], function()&#123; //typeString显示完一个短句,再回调,设置下一个短句的定时显示 timeout = setTimeout(function()&#123; self.processText(self.options.loop ? ((index + 1) % self.texts.length) : (index + 1)); &#125;, self.options.textDelay); self.timeouts.push(timeout); &#125;);&#125;//textPlaceHolder.prototype.typeString = function(str, callback)&#123; var self = this, timeout; if(!str)&#123; return false; &#125; //给每增加一个字符显示设置定时,即每增加一个letterDelay, 调用函数给input的placeholder设置对应的str for(let i = 0; i &lt; str.length; i++)&#123; timeout = setTimeout(setTimeoutCallback, i * self.options.letterDelay, i); self.timeouts.push(timeout); &#125; // function setTimeoutCallback(index)&#123; //index == str.length - 1 便是显示到了一个text的最后的一个字符 self.el.setAttribute('placeholder', str.substring(0, index + 1) + (index === str.length - 1 || !self.options.showCursor ? '' : self.options.cursor)); if(index == str.length - 1)&#123; callback(); //一个text显示完整后,回调,设置下一个text的 &#125; &#125;&#125;//失去焦点之后触发,设置为原来的默认值, 并且清空定时器PlaceHolder.prototype.cleanUp = function()&#123; // Stop timeouts for (var i = this.timeouts.length; i--;) &#123; clearTimeout(this.timeouts[i]); &#125; this.el.setAttribute('placeholder', this.originalPlaceholder); this.timeouts.length = 0;&#125; 声明PlaceHolder对象函数,判断是否支持placeholder属性,并new之前的构造函数, 并抛出该函数对象1234567891011121314151617181920var splaceholder = function(params)&#123; if(!isPlaceHolderSupported)&#123; return; &#125; new PlaceHolder(params.el, params.texts, params.options);&#125;if( typeof exports === 'object' ) &#123; module.exports = splaceholder;&#125;// AMD moduleelse if( typeof define === 'function' &amp;&amp; define.amd ) &#123; define(function () &#123; return splaceholder; &#125;);&#125;// 浏览器window对象else &#123; window.splaceholder = splaceholder;&#125; 好的,接下来我们只要在页面调用就好了1234567891011&lt;input type=\"text\" name=\"\" placeholder=\"colleague\" id=\"colleague\"&gt;splaceholder(&#123; el: colleague, texts: [\"caishuanglin\", \"linxianshen\", \"xinmencai\"], options: &#123; loop: true, letterDelay: 100, startOnFocus: false &#125;&#125;) 嗯,自己动手试试吧.(ง •̀_•́)ง","tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://linxianshen.github.io/tags/javaScript/"},{"name":"placeholder","slug":"placeholder","permalink":"https://linxianshen.github.io/tags/placeholder/"}]},{"title":"Hello World","date":"2017-03-16T09:04:57.000Z","path":"2017/03/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]